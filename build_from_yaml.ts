import { parse } from 'yaml';
import { readFile, writeFile } from 'fs';
import { Cv, Skill, SkillOption } from './src/app/cv';

function readYaml(file :string) : Promise<Cv>{
	return new Promise( (resolve, reject) => {
		readFile(file, 'utf8', (err, data) => {
			let cv = new Cv; // new cv for yaml data
			if (err !== null) {
				return reject(err);
			}
			console.log(data); // print so input is visible in cicd logs
			let parsed = parse(data);

			// generate skills
			if (parsed.skills.length != 0){
				try {
					cv.skills = genSkills(parsed.skills);
				} catch (e) {
					return reject(e);
				}
				return resolve(cv);
			}
		});
	});
}

// generates js skills from yaml skills
function genSkills(yamlSkills :any) :Skill[] {
	let skills = [];
	yamlSkills.forEach( (v) => {
		let skill = new Skill;
		if (typeof v === "object"){
			skill = genSkill(v);
		} else if (typeof v === "string") {
			// if string assumed to be a skill which matches to same name topics
			skill.name = v;
		} else {
			throw "unsupported field in "+v as string;
		}
		skills.push(skill);
	});
	return skills;
}

// generates a js skill from a yaml skill definitions with options, simple one line skills are generated by parent function genSkills
function genSkill(item :any) :Skill {
	let skill = new Skill;
	let fields = Object.getOwnPropertyNames(item);
	if (fields.length != 1) {
		throw "skill with more than one (or 0) names, should not be possible";
	}
	skill.name = fields[0];
	let skillOpt = new SkillOption;
	item[fields[0]].forEach( (option) => {
		if (typeof option === "object") {
			// if child is an object, it must be a reserved keyword
			Object.getOwnPropertyNames(option).forEach( (optName) => {
				switch (optName) {
					case "text":
						skill.text = option[optName];
						break;
					case 'file':
						skillOpt.file = option[optName];
						break;
					case 'rfile':
						skillOpt.rfile = option[optName];
						break;
					default:
						throw "invalid option name "+optName;
				}
			});
		} else if (typeof option === "string") {
			// if child is a string, assumed to be a topic. Multiple topics to match with are allowed.
			if (!skillOpt.hasOwnProperty("topics")) {
				skillOpt.topics = [];
			}
			skillOpt.topics.push(option);
		} else {
			// we should not get here
			throw "invalid yaml for cv";
		}
		if (Object.getOwnPropertyNames(skillOpt).length !== 0) {
			skill.options = skillOpt;
		}
	});
	return skill;
}

function readOldJson(file :string) : Promise<Cv>{
	return new Promise( (resolve, reject) => {
		readFile(file, 'utf8', (err, data) => {
			if (err !== null) {
				return reject(err);
			}
			return resolve(JSON.parse(data));
		});
	});
}

function combine(oldCv :Cv, newCv :Cv) :Cv{
	for (const key in oldCv) {
		newCv[key] = oldCv[key];
	}
	// newCv["causefailure"] = "matt daemon";
	return newCv;
}

async function main() {
	let newCv = readYaml("cv.yml");
	let oldCv = readOldJson("data.json");
	let cvs = await Promise.all([oldCv, newCv]).catch( e => { return e;} );
	if (!Array.isArray(cvs)) { //if cvs isn't an array it must contain an error, due to being a Promise made will Promise.all
		return console.error(cvs);
	}

	let cv = combine(cvs[0], cvs[1]); // replace existing fields into new fields

	let payload = JSON.stringify(cv);
	writeFile("cv.json", payload, 'utf-8', err => {
		if (err !== null) {
			throw "error writing file, error: "+err as string;
		} else {
			console.log("succesfully parsed yaml and generated json cv");
		}
	});
}

if (require.main === module) {
	main();
}
